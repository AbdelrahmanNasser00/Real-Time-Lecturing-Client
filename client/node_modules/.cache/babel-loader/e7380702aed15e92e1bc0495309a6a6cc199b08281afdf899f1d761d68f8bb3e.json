{"ast":null,"code":"import { createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { setLocalStream, setRemoteStreams } from \"../store/roomSlice\";\nimport Peer from \"simple-peer\";\nimport * as socketConnection from \"./socketConnection\";\nconst getConfiguration = () => {\n  const turnIceServers = null;\n  if (turnIceServers) {\n    // TODO use TURN server credentials\n  } else {\n    console.warn(\"Using only STUN server\");\n    return {\n      iceServers: [{\n        urls: \"stun:stun.l.google.com:19302\"\n      }]\n    };\n  }\n};\nexport const getLocalStreamPreview = createAsyncThunk(\"room/getLocalStreamPreview\", async (callbackFunc, {\n  dispatch\n}) => {\n  try {\n    const constraints = {\n      video: true,\n      audio: true\n    };\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    dispatch(setLocalStream(stream));\n    callbackFunc();\n  } catch (error) {\n    console.error(error);\n    console.log(\"Cannot get an access to local stream\");\n  }\n});\nlet peers = {};\nexport const prepareNewPeerConnection = (connUserSocketId, isInitiator) => (dispatch, getState) => {\n  const localStream = getState().room.localStream;\n  if (isInitiator) {\n    console.log(\"preparing new peer connection as initiator\");\n  } else {\n    console.log(\"preparing new peer connection as not initiator\");\n  }\n  peers[connUserSocketId] = new Peer({\n    initiator: isInitiator,\n    config: getConfiguration(),\n    stream: localStream\n  });\n  peers[connUserSocketId].on(\"signal\", data => {\n    const signalData = {\n      signal: data,\n      connUserSocketId: connUserSocketId\n    };\n    socketConnection.signalPeerData(signalData);\n  });\n  peers[connUserSocketId].on(\"stream\", remoteStream => {\n    // TODO\n    // add new remote stream to our server store\n    console.log(\"remote stream came from other user\");\n    console.log(\"direct connection has been established\");\n    remoteStream.connUserSocketId = connUserSocketId;\n    dispatch(addNewRemoteStream(remoteStream));\n  });\n};\nexport const handleSignalingData = data => {\n  const {\n    connUserSocketId,\n    signal\n  } = data;\n  if (peers[connUserSocketId]) {\n    peers[connUserSocketId].signal(signal);\n  }\n};\nconst addNewRemoteStream = createAsyncThunk(\"room/addNewRemoteStream\", async (remoteStream, {\n  dispatch,\n  getState\n}) => {\n  const remoteStreams = getState().room.remoteStreams;\n  const newRemoteStreams = [...remoteStreams, remoteStream];\n  dispatch(setRemoteStreams(newRemoteStreams));\n});\nexport const closeAllConnections = createAsyncThunk(\"room/closeAllConnections\", (_, {\n  getState\n}) => {\n  Object.entries(peers).forEach(mappedObject => {\n    const connUserSocketId = mappedObject[0];\n    if (peers[connUserSocketId]) {\n      peers[connUserSocketId].destroy();\n      delete peers[connUserSocketId];\n    }\n  });\n});\nexport const handleParticipantLeftRoom = createAsyncThunk(\"room/handleParticipantLeftRoom\", async (data, {\n  dispatch,\n  getState\n}) => {\n  const {\n    connUserSocketId\n  } = data;\n  if (peers[connUserSocketId]) {\n    peers[connUserSocketId].destroy();\n    delete peers[connUserSocketId];\n  }\n  const remoteStreams = getState().room.remoteStreams;\n  const newRemoteStreams = remoteStreams.filter(remoteStream => remoteStream.connUserSocketId !== connUserSocketId);\n  dispatch(setRemoteStreams(newRemoteStreams));\n});\nexport const switchOutgoingTracks = stream => {\n  for (let socket_id in peers) {\n    for (let index in peers[socket_id].streams[0].getTracks()) {\n      for (let index2 in stream.getTracks()) {\n        if (peers[socket_id].streams[0].getTracks()[index].kind === stream.getTracks()[index2].kind) {\n          peers[socket_id].replaceTrack(peers[socket_id].streams[0].getTracks()[index], stream.getTracks()[index2], peers[socket_id].streams[0]);\n          break;\n        }\n      }\n    }\n  }\n};","map":{"version":3,"names":["createAsyncThunk","setLocalStream","setRemoteStreams","Peer","socketConnection","getConfiguration","turnIceServers","console","warn","iceServers","urls","getLocalStreamPreview","callbackFunc","dispatch","constraints","video","audio","stream","navigator","mediaDevices","getUserMedia","error","log","peers","prepareNewPeerConnection","connUserSocketId","isInitiator","getState","localStream","room","initiator","config","on","data","signalData","signal","signalPeerData","remoteStream","addNewRemoteStream","handleSignalingData","remoteStreams","newRemoteStreams","closeAllConnections","_","Object","entries","forEach","mappedObject","destroy","handleParticipantLeftRoom","filter","switchOutgoingTracks","socket_id","index","streams","getTracks","index2","kind","replaceTrack"],"sources":["/home/abdelrahman/Documents/Realtime-project/client/Real-Time-Lecturing-Client/client/src/realtimeCommunication/webRTCHandler.js"],"sourcesContent":["import { createAsyncThunk } from \"@reduxjs/toolkit\";\r\nimport { setLocalStream, setRemoteStreams } from \"../store/roomSlice\";\r\nimport Peer from \"simple-peer\";\r\nimport * as socketConnection from \"./socketConnection\";\r\n\r\nconst getConfiguration = () => {\r\n  const turnIceServers = null;\r\n\r\n  if (turnIceServers) {\r\n    // TODO use TURN server credentials\r\n  } else {\r\n    console.warn(\"Using only STUN server\");\r\n    return {\r\n      iceServers: [\r\n        {\r\n          urls: \"stun:stun.l.google.com:19302\",\r\n        },\r\n      ],\r\n    };\r\n  }\r\n};\r\n\r\nexport const getLocalStreamPreview = createAsyncThunk(\r\n  \"room/getLocalStreamPreview\",\r\n  async (callbackFunc, { dispatch }) => {\r\n    try {\r\n      const constraints = {\r\n        video: true,\r\n        audio: true,\r\n      };\r\n\r\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\r\n      dispatch(setLocalStream(stream));\r\n      callbackFunc();\r\n    } catch (error) {\r\n      console.error(error);\r\n      console.log(\"Cannot get an access to local stream\");\r\n    }\r\n  }\r\n);\r\n\r\nlet peers = {};\r\n\r\nexport const prepareNewPeerConnection =\r\n  (connUserSocketId, isInitiator) => (dispatch, getState) => {\r\n    const localStream = getState().room.localStream;\r\n\r\n    if (isInitiator) {\r\n      console.log(\"preparing new peer connection as initiator\");\r\n    } else {\r\n      console.log(\"preparing new peer connection as not initiator\");\r\n    }\r\n\r\n    peers[connUserSocketId] = new Peer({\r\n      initiator: isInitiator,\r\n      config: getConfiguration(),\r\n      stream: localStream,\r\n    });\r\n\r\n    peers[connUserSocketId].on(\"signal\", (data) => {\r\n      const signalData = {\r\n        signal: data,\r\n        connUserSocketId: connUserSocketId,\r\n      };\r\n\r\n      socketConnection.signalPeerData(signalData);\r\n    });\r\n\r\n    peers[connUserSocketId].on(\"stream\", (remoteStream) => {\r\n      // TODO\r\n      // add new remote stream to our server store\r\n      console.log(\"remote stream came from other user\");\r\n      console.log(\"direct connection has been established\");\r\n      remoteStream.connUserSocketId = connUserSocketId;\r\n      dispatch(addNewRemoteStream(remoteStream));\r\n    });\r\n  };\r\n\r\nexport const handleSignalingData = (data) => {\r\n  const { connUserSocketId, signal } = data;\r\n\r\n  if (peers[connUserSocketId]) {\r\n    peers[connUserSocketId].signal(signal);\r\n  }\r\n};\r\n\r\nconst addNewRemoteStream = createAsyncThunk(\r\n  \"room/addNewRemoteStream\",\r\n  async (remoteStream, { dispatch, getState }) => {\r\n    const remoteStreams = getState().room.remoteStreams;\r\n    const newRemoteStreams = [...remoteStreams, remoteStream];\r\n    dispatch(setRemoteStreams(newRemoteStreams));\r\n  }\r\n);\r\n\r\nexport const closeAllConnections = createAsyncThunk(\r\n  \"room/closeAllConnections\",\r\n  (_, { getState }) => {\r\n    Object.entries(peers).forEach((mappedObject) => {\r\n      const connUserSocketId = mappedObject[0];\r\n      if (peers[connUserSocketId]) {\r\n        peers[connUserSocketId].destroy();\r\n        delete peers[connUserSocketId];\r\n      }\r\n    });\r\n  }\r\n);\r\n\r\nexport const handleParticipantLeftRoom = createAsyncThunk(\r\n  \"room/handleParticipantLeftRoom\",\r\n  async (data, { dispatch, getState }) => {\r\n    const { connUserSocketId } = data;\r\n\r\n    if (peers[connUserSocketId]) {\r\n      peers[connUserSocketId].destroy();\r\n      delete peers[connUserSocketId];\r\n    }\r\n\r\n    const remoteStreams = getState().room.remoteStreams;\r\n\r\n    const newRemoteStreams = remoteStreams.filter(\r\n      (remoteStream) => remoteStream.connUserSocketId !== connUserSocketId\r\n    );\r\n\r\n    dispatch(setRemoteStreams(newRemoteStreams));\r\n  }\r\n);\r\n\r\nexport const switchOutgoingTracks = (stream) => {\r\n  for (let socket_id in peers) {\r\n    for (let index in peers[socket_id].streams[0].getTracks()) {\r\n      for (let index2 in stream.getTracks()) {\r\n        if (\r\n          peers[socket_id].streams[0].getTracks()[index].kind ===\r\n          stream.getTracks()[index2].kind\r\n        ) {\r\n          peers[socket_id].replaceTrack(\r\n            peers[socket_id].streams[0].getTracks()[index],\r\n            stream.getTracks()[index2],\r\n            peers[socket_id].streams[0]\r\n          );\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}